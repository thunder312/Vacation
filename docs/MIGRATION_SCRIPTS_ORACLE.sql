-- ============================================================================
-- ORACLE DATABASE MIGRATION SCRIPTS
-- Urlaubsverwaltungssystem - Schema und Datenmigration
-- ============================================================================

-- ============================================================================
-- TEIL 1: TABLESPACE UND USER ERSTELLEN (als SYSDBA ausführen)
-- ============================================================================

-- Tablespace erstellen
-- CREATE TABLESPACE vacation_ts
--     DATAFILE 'vacation_ts.dbf' SIZE 100M
--     AUTOEXTEND ON NEXT 50M MAXSIZE UNLIMITED;

-- User erstellen
-- CREATE USER vacation_user IDENTIFIED BY vacation_password
--     DEFAULT TABLESPACE vacation_ts
--     QUOTA UNLIMITED ON vacation_ts;

-- Rechte vergeben
-- GRANT CONNECT, RESOURCE, CREATE VIEW, CREATE PROCEDURE, CREATE TRIGGER TO vacation_user;

-- ============================================================================
-- TEIL 2: TABELLEN ERSTELLEN (als vacation_user ausführen)
-- ============================================================================

-- 1. Users Tabelle
CREATE TABLE users (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR2(100) NOT NULL UNIQUE,
    password VARCHAR2(255) NOT NULL,
    first_name VARCHAR2(100) NOT NULL,
    last_name VARCHAR2(100) NOT NULL,
    role VARCHAR2(20) DEFAULT 'employee' NOT NULL,
    vacation_days NUMBER(3) DEFAULT 30 NOT NULL,
    is_active NUMBER(1) DEFAULT 1 NOT NULL,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP,

    CONSTRAINT ck_users_role CHECK (role IN ('employee', 'teamlead', 'manager', 'office', 'sysadmin')),
    CONSTRAINT ck_users_is_active CHECK (is_active IN (0, 1))
);

CREATE INDEX ix_users_username ON users(username);
CREATE INDEX ix_users_role ON users(role);
CREATE INDEX ix_users_is_active ON users(is_active);

COMMENT ON TABLE users IS 'Benutzer des Urlaubsverwaltungssystems';
COMMENT ON COLUMN users.role IS 'Rolle: employee, teamlead, manager, office, sysadmin';
/

-- 2. Vacation Requests Tabelle
CREATE TABLE vacation_requests (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id VARCHAR2(100) NOT NULL,
    display_name VARCHAR2(200) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    reason CLOB,
    status VARCHAR2(20) DEFAULT 'pending' NOT NULL,
    teamlead_approval_date TIMESTAMP,
    manager_approval_date TIMESTAMP,
    cancel_reason CLOB,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,

    CONSTRAINT fk_vacation_requests_user FOREIGN KEY (user_id) REFERENCES users(username),
    CONSTRAINT ck_vacation_requests_status CHECK (status IN ('pending', 'teamlead_approved', 'approved', 'rejected', 'cancelled')),
    CONSTRAINT ck_vacation_requests_dates CHECK (end_date >= start_date)
);

CREATE INDEX ix_vacation_requests_user_id ON vacation_requests(user_id);
CREATE INDEX ix_vacation_requests_status ON vacation_requests(status);
CREATE INDEX ix_vacation_requests_start_date ON vacation_requests(start_date);
CREATE INDEX ix_vacation_requests_created_at ON vacation_requests(created_at DESC);

COMMENT ON TABLE vacation_requests IS 'Urlaubsanträge';
/

-- 3. Organization Tabelle
CREATE TABLE organization (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id VARCHAR2(100) NOT NULL UNIQUE,
    teamlead_id VARCHAR2(100),
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,

    CONSTRAINT fk_organization_user FOREIGN KEY (user_id) REFERENCES users(username),
    CONSTRAINT fk_organization_teamlead FOREIGN KEY (teamlead_id) REFERENCES users(username)
);

CREATE INDEX ix_organization_teamlead_id ON organization(teamlead_id);

COMMENT ON TABLE organization IS 'Organisationsstruktur - Zuordnung User zu Teamleiter';
/

-- 4. Carryover Tabelle
CREATE TABLE carryover (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id VARCHAR2(100) NOT NULL,
    year NUMBER(4) NOT NULL,
    calculated_days NUMBER(5,1) NOT NULL,
    approved_days NUMBER(5,1),
    reason CLOB,
    status VARCHAR2(20) DEFAULT 'pending' NOT NULL,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,

    CONSTRAINT fk_carryover_user FOREIGN KEY (user_id) REFERENCES users(username),
    CONSTRAINT uq_carryover_user_year UNIQUE (user_id, year),
    CONSTRAINT ck_carryover_status CHECK (status IN ('pending', 'approved'))
);

CREATE INDEX ix_carryover_year ON carryover(year);

COMMENT ON TABLE carryover IS 'Resturlaubs-Übertrag ins neue Jahr';
/

-- 5. Half Day Rules Tabelle
CREATE TABLE half_day_rules (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    rule_date DATE NOT NULL UNIQUE,
    description VARCHAR2(255) NOT NULL,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE INDEX ix_half_day_rules_date ON half_day_rules(rule_date);

COMMENT ON TABLE half_day_rules IS 'Halbtags-Regelungen (z.B. Heiligabend)';
/

-- 6. Vacation Exceptions Tabelle
CREATE TABLE vacation_exceptions (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    vacation_request_id NUMBER NOT NULL,
    user_id VARCHAR2(100) NOT NULL,
    exception_date DATE NOT NULL,
    deduction NUMBER(3,1) NOT NULL,
    reason CLOB NOT NULL,
    created_by VARCHAR2(100) NOT NULL,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,

    CONSTRAINT fk_vacation_exceptions_request FOREIGN KEY (vacation_request_id) REFERENCES vacation_requests(id),
    CONSTRAINT fk_vacation_exceptions_user FOREIGN KEY (user_id) REFERENCES users(username),
    CONSTRAINT uq_vacation_exceptions_req_date UNIQUE (vacation_request_id, exception_date)
);

CREATE INDEX ix_vacation_exceptions_user_id ON vacation_exceptions(user_id);

COMMENT ON TABLE vacation_exceptions IS 'Urlaubsrückbuchungen für einzelne Tage';
/

-- ============================================================================
-- TEIL 3: TRIGGER
-- ============================================================================

-- Trigger für updated_at auf users
CREATE OR REPLACE TRIGGER trg_users_update
BEFORE UPDATE ON users
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- ============================================================================
-- TEIL 4: STORED PROCEDURES
-- ============================================================================

-- Package für Urlaubsverwaltung
CREATE OR REPLACE PACKAGE pkg_vacation AS
    -- Benutzer erstellen
    PROCEDURE create_user(
        p_username IN VARCHAR2,
        p_password IN VARCHAR2,
        p_first_name IN VARCHAR2,
        p_last_name IN VARCHAR2,
        p_role IN VARCHAR2 DEFAULT 'employee',
        p_vacation_days IN NUMBER DEFAULT 30,
        p_teamlead_id IN VARCHAR2 DEFAULT NULL,
        p_user_id OUT NUMBER
    );

    -- Urlaubsantrag erstellen
    PROCEDURE create_vacation_request(
        p_user_id IN VARCHAR2,
        p_display_name IN VARCHAR2,
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_reason IN CLOB DEFAULT NULL,
        p_request_id OUT NUMBER
    );

    -- Urlaubsantrag genehmigen
    PROCEDURE approve_vacation_request(
        p_request_id IN NUMBER,
        p_approval_level IN VARCHAR2, -- 'teamlead' oder 'manager'
        p_rows_affected OUT NUMBER
    );

    -- Urlaubsantrag ablehnen
    PROCEDURE reject_vacation_request(
        p_request_id IN NUMBER,
        p_rows_affected OUT NUMBER
    );

    -- Urlaubsantrag stornieren
    PROCEDURE cancel_vacation_request(
        p_request_id IN NUMBER,
        p_cancel_reason IN CLOB,
        p_rows_affected OUT NUMBER
    );

    -- Urlaubssaldo berechnen
    FUNCTION get_vacation_balance(
        p_username IN VARCHAR2,
        p_year IN NUMBER
    ) RETURN SYS_REFCURSOR;
END pkg_vacation;
/

CREATE OR REPLACE PACKAGE BODY pkg_vacation AS

    PROCEDURE create_user(
        p_username IN VARCHAR2,
        p_password IN VARCHAR2,
        p_first_name IN VARCHAR2,
        p_last_name IN VARCHAR2,
        p_role IN VARCHAR2 DEFAULT 'employee',
        p_vacation_days IN NUMBER DEFAULT 30,
        p_teamlead_id IN VARCHAR2 DEFAULT NULL,
        p_user_id OUT NUMBER
    ) AS
    BEGIN
        INSERT INTO users (username, password, first_name, last_name, role, vacation_days)
        VALUES (p_username, p_password, p_first_name, p_last_name, p_role, p_vacation_days)
        RETURNING id INTO p_user_id;

        INSERT INTO organization (user_id, teamlead_id)
        VALUES (p_username, p_teamlead_id);

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END create_user;

    PROCEDURE create_vacation_request(
        p_user_id IN VARCHAR2,
        p_display_name IN VARCHAR2,
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_reason IN CLOB DEFAULT NULL,
        p_request_id OUT NUMBER
    ) AS
    BEGIN
        INSERT INTO vacation_requests (user_id, display_name, start_date, end_date, reason)
        VALUES (p_user_id, p_display_name, p_start_date, p_end_date, p_reason)
        RETURNING id INTO p_request_id;

        COMMIT;
    END create_vacation_request;

    PROCEDURE approve_vacation_request(
        p_request_id IN NUMBER,
        p_approval_level IN VARCHAR2,
        p_rows_affected OUT NUMBER
    ) AS
    BEGIN
        IF p_approval_level = 'teamlead' THEN
            UPDATE vacation_requests
            SET status = 'teamlead_approved',
                teamlead_approval_date = SYSTIMESTAMP
            WHERE id = p_request_id AND status = 'pending';
        ELSIF p_approval_level = 'manager' THEN
            UPDATE vacation_requests
            SET status = 'approved',
                manager_approval_date = SYSTIMESTAMP
            WHERE id = p_request_id AND status IN ('pending', 'teamlead_approved');
        END IF;

        p_rows_affected := SQL%ROWCOUNT;
        COMMIT;
    END approve_vacation_request;

    PROCEDURE reject_vacation_request(
        p_request_id IN NUMBER,
        p_rows_affected OUT NUMBER
    ) AS
    BEGIN
        UPDATE vacation_requests
        SET status = 'rejected'
        WHERE id = p_request_id AND status IN ('pending', 'teamlead_approved');

        p_rows_affected := SQL%ROWCOUNT;
        COMMIT;
    END reject_vacation_request;

    PROCEDURE cancel_vacation_request(
        p_request_id IN NUMBER,
        p_cancel_reason IN CLOB,
        p_rows_affected OUT NUMBER
    ) AS
    BEGIN
        UPDATE vacation_requests
        SET status = 'cancelled',
            cancel_reason = p_cancel_reason
        WHERE id = p_request_id AND status = 'approved';

        p_rows_affected := SQL%ROWCOUNT;
        COMMIT;
    END cancel_vacation_request;

    FUNCTION get_vacation_balance(
        p_username IN VARCHAR2,
        p_year IN NUMBER
    ) RETURN SYS_REFCURSOR AS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            WITH approved_days AS (
                SELECT NVL(SUM(end_date - start_date + 1), 0) AS used_days
                FROM vacation_requests
                WHERE user_id = p_username
                  AND status = 'approved'
                  AND EXTRACT(YEAR FROM start_date) = p_year
            ),
            carryover_days AS (
                SELECT NVL(approved_days, calculated_days) AS carryover
                FROM carryover
                WHERE user_id = p_username AND year = p_year
            )
            SELECT
                u.vacation_days + NVL(c.carryover, 0) AS total_days,
                a.used_days,
                u.vacation_days + NVL(c.carryover, 0) - a.used_days AS remaining_days,
                NVL(c.carryover, 0) AS carryover_days
            FROM users u
            CROSS JOIN approved_days a
            LEFT JOIN carryover_days c ON 1=1
            WHERE u.username = p_username;

        RETURN v_cursor;
    END get_vacation_balance;

END pkg_vacation;
/

-- ============================================================================
-- TEIL 5: VIEWS
-- ============================================================================

-- Übersicht aller Urlaubsanträge mit User-Details
CREATE OR REPLACE VIEW vw_vacation_requests_detailed AS
SELECT
    vr.id,
    vr.user_id,
    u.first_name || ' ' || u.last_name AS display_name,
    vr.start_date,
    vr.end_date,
    vr.end_date - vr.start_date + 1 AS total_days,
    vr.reason,
    vr.status,
    vr.teamlead_approval_date,
    vr.manager_approval_date,
    vr.cancel_reason,
    vr.created_at,
    u.role AS user_role,
    o.teamlead_id,
    tl.first_name || ' ' || tl.last_name AS teamlead_name
FROM vacation_requests vr
INNER JOIN users u ON vr.user_id = u.username
LEFT JOIN organization o ON vr.user_id = o.user_id
LEFT JOIN users tl ON o.teamlead_id = tl.username;
/

-- Team-Übersicht für Teamleiter
CREATE OR REPLACE VIEW vw_team_overview AS
SELECT
    o.teamlead_id,
    tl.first_name || ' ' || tl.last_name AS teamlead_name,
    u.username AS member_id,
    u.first_name || ' ' || u.last_name AS member_name,
    u.role AS member_role,
    u.vacation_days,
    u.is_active
FROM organization o
INNER JOIN users u ON o.user_id = u.username
LEFT JOIN users tl ON o.teamlead_id = tl.username
WHERE u.is_active = 1;
/

-- Jahresübersicht für Berichte
CREATE OR REPLACE VIEW vw_annual_report AS
SELECT
    u.username,
    u.first_name || ' ' || u.last_name AS display_name,
    u.vacation_days AS entitlement,
    NVL(c.approved_days, c.calculated_days) AS carryover,
    u.vacation_days + NVL(c.approved_days, c.calculated_days) AS total_available,
    NVL(approved.used_days, 0) AS used_days,
    u.vacation_days + NVL(c.approved_days, c.calculated_days) - NVL(approved.used_days, 0) AS remaining
FROM users u
LEFT JOIN carryover c ON u.username = c.user_id AND c.year = EXTRACT(YEAR FROM SYSDATE)
LEFT JOIN (
    SELECT
        user_id,
        SUM(end_date - start_date + 1) AS used_days
    FROM vacation_requests
    WHERE status = 'approved'
      AND EXTRACT(YEAR FROM start_date) = EXTRACT(YEAR FROM SYSDATE)
    GROUP BY user_id
) approved ON u.username = approved.user_id
WHERE u.is_active = 1;
/

-- ============================================================================
-- TEIL 6: ADMIN-BENUTZER ERSTELLEN
-- ============================================================================

-- Admin-User erstellen
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM users WHERE username = 'admin';

    IF v_count = 0 THEN
        -- HINWEIS: Der bcrypt-Hash muss in der Anwendung generiert werden
        INSERT INTO users (username, password, first_name, last_name, role, vacation_days, is_active)
        VALUES ('admin', '$2b$10$placeholder_hash_generate_in_app', 'Admin', 'User', 'sysadmin', 30, 1);

        INSERT INTO organization (user_id, teamlead_id)
        VALUES ('admin', NULL);

        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Admin-User erstellt');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Admin-User existiert bereits');
    END IF;
END;
/

-- ============================================================================
-- TEIL 7: BEISPIEL-DATEN FÜR HALBTAGE
-- ============================================================================

INSERT INTO half_day_rules (rule_date, description) VALUES (TO_DATE('2026-12-24', 'YYYY-MM-DD'), 'Heiligabend');
INSERT INTO half_day_rules (rule_date, description) VALUES (TO_DATE('2026-12-31', 'YYYY-MM-DD'), 'Silvester');
INSERT INTO half_day_rules (rule_date, description) VALUES (TO_DATE('2026-01-05', 'YYYY-MM-DD'), 'Heilige Drei Könige (Vorabend)');
COMMIT;
/

-- ============================================================================
-- TEIL 8: GRANTS FÜR ANWENDUNGSBENUTZER (optional)
-- ============================================================================

-- Falls ein separater App-User verwendet wird:
-- GRANT SELECT, INSERT, UPDATE, DELETE ON users TO app_user;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON vacation_requests TO app_user;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON organization TO app_user;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON carryover TO app_user;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON half_day_rules TO app_user;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON vacation_exceptions TO app_user;
-- GRANT EXECUTE ON pkg_vacation TO app_user;

PROMPT === Oracle Migration abgeschlossen ===
/
